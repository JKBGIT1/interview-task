require 'yaml'

workers_count = 2
masters_count = 1
lbs_count = 1
lbs_starting_ip = 3

if lbs_starting_ip != 3
  raise "Load balancers starting IP must be 3"
end

starting_octet = lbs_starting_ip + lbs_count

if lbs_count != 1
  raise "Load balancers count must be exactly 1 for this setup"
end

if starting_octet < lbs_starting_ip + lbs_count
  raise "Keep the starting_octet at #{lbs_starting_ip + lbs_count}"
end

if masters_count.even? || masters_count < 1
  raise "Masters count must be an odd number greater than 0"
end

# load kubeone.yaml
config_file = File.join(File.dirname(__FILE__), "../kubeone/kubeone.yaml")
unless File.exist?(config_file)
  raise "Configuration file kubeone.yaml not found in ../kubeone directory"
end

yaml_data = YAML.load_file(config_file)
yaml_data["controlPlane"]["hosts"] = []
yaml_data["staticWorkers"]["hosts"] = []

worker_ips = workers_count.times.map { |i| "192.168.56.#{starting_octet + masters_count + i}" }

nginx_template_file = File.join(File.dirname(__FILE__), "../lbs/nginx/nginx.conf.erb")
nginx_output_file = File.join(File.dirname(__FILE__), "../lbs/nginx/nginx.conf")
nginx_conf = File.read(nginx_template_file)
nginx_conf.gsub!("${{ worker_ips:31443 }}", worker_ips.map { |ip| "        server #{ip}:31443;" }.join("\n"))
nginx_conf.gsub!("${{ worker_ips:31080 }}", worker_ips.map { |ip| "        server #{ip}:31080;" }.join("\n"))
File.open(nginx_output_file, "w") { |f| f.write(nginx_conf) }

Vagrant.configure("2") do |config|
  # forbid root login and password authentication
  config.vm.provision "shell", inline: <<-SHELL
    cat <<EOF > /etc/ssh/sshd_config.d/01-security.conf
# Disable root login and password authentication for better security
PermitRootLogin no
PasswordAuthentication no
PermitEmptyPasswords no
EOF
    systemctl restart ssh
  SHELL

  masters_count.times do |i|
    master_name = "master-#{i + 1}"
    master_config = {
      ip: "192.168.56.#{starting_octet + i}",
      cpus: 2,
      memory: 4096
    }

    yaml_data["controlPlane"]["hosts"].push(
      {
        "privateAddress" => master_config[:ip],
        "sshUsername" => "vagrant",
        "sshPrivateKeyFile" => "../vagrant/.vagrant/machines/#{master_name}/virtualbox/private_key",
        "taints" => [
          {
            "key" => "node-role.kubernetes.io/control-plane",
            "effect" => "NoSchedule"
          }
        ]
      }
    )

    if i == 0
      yaml_data["apiEndpoint"] = {
        "host" => master_config[:ip],
        "port" => 6443
      }
    end

    config.vm.define master_name do |master|
      master.vm.box = "bento/ubuntu-24.04"
      master.vm.box_version = "202510.26.0"
      master.vm.hostname = master_name
      master.vm.network "private_network", ip: master_config[:ip]
      master.vm.provider "virtualbox" do |vb|
        vb.cpus = master_config[:cpus]
        vb.memory = master_config[:memory]
      end
    end
  end

  workers_count.times do |i|
    worker_name = "worker-#{i + 1}"
    worker_config = {
      ip: "192.168.56.#{starting_octet + masters_count + i}",
      cpus: 2,
      memory: 4096
    }

    yaml_data["staticWorkers"]["hosts"].push(
      {
        "privateAddress" => worker_config[:ip],
        "sshUsername" => "vagrant",
        "sshPrivateKeyFile" => "../vagrant/.vagrant/machines/#{worker_name}/virtualbox/private_key"
      }
    )

    config.vm.define worker_name do |worker|
      worker.vm.box = "bento/ubuntu-24.04"
      worker.vm.box_version = "202510.26.0"
      worker.vm.hostname = worker_name
      worker.vm.network "private_network", ip: worker_config[:ip]
      worker.vm.provider "virtualbox" do |vb|
        vb.cpus = worker_config[:cpus]
        vb.memory = worker_config[:memory]
      end
    end
  end

  File.open(config_file, "w") do |file|
    file.write(yaml_data.to_yaml)
  end

  lbs_count.times do |i|
    lb_name = "lb-#{i + 1}"
    lb_config = {
      ip: "192.168.56.#{3 + i}",
      cpus: 1,
      memory: 1024
    }

    config.vm.define lb_name do |lb|
      lb.vm.box = "bento/ubuntu-24.04"
      lb.vm.box_version = "202510.26.0"
      lb.vm.hostname = lb_name
      lb.vm.network "private_network", ip: lb_config[:ip]
      lb.vm.provider "virtualbox" do |vb|
        vb.cpus = lb_config[:cpus]
        vb.memory = lb_config[:memory]
      end
      
      lb.vm.synced_folder "../lbs", "/opt/lbs"

      lb.vm.provision "shell", inline: <<-SHELL
        # install docker and start nginx load balancer
        apt-get update
        apt-get install -y ca-certificates curl
        install -m 0755 -d /etc/apt/keyrings
        curl -fsSL https://download.docker.com/linux/ubuntu/gpg -o /etc/apt/keyrings/docker.asc
        chmod a+r /etc/apt/keyrings/docker.asc
        echo "deb [arch=$(dpkg --print-architecture) signed-by=/etc/apt/keyrings/docker.asc] https://download.docker.com/linux/ubuntu $(. /etc/os-release && echo "$VERSION_CODENAME") stable" | tee /etc/apt/sources.list.d/docker.list > /dev/null
        apt-get update
        apt-get install -y docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin
        systemctl enable docker
        systemctl start docker
        cd /opt/lbs && docker compose up -d

        # setup basic firewall rules with ufw allowing only HTTP, HTTPS and SSH
        ufw default deny incoming
        ufw default allow outgoing
        ufw allow 22/tcp
        ufw allow 80/tcp
        ufw allow 443/tcp
        ufw --force enable
      SHELL
    end
  end

  config.vm.define "dns-server" do |dns|
    dns.vm.box = "bento/ubuntu-24.04"
    dns.vm.box_version = "202510.26.0"
    dns.vm.hostname = "dns-server"
    dns.vm.network "private_network", ip: "192.168.56.2" # the 192.168.56.1 is reserved for the router
    dns.vm.provider "virtualbox" do |vb|
      vb.cpus = 1
      vb.memory = 1024
    end

    # Build dnsmasq config with LBs' IPs for round-robin
    dnsmasq_config = "# disable dns forwarding for .test domain\n"
    dnsmasq_config += "local=/test/\n"
    dnsmasq_config += "local-ttl=30\n"
    dnsmasq_config += "log-queries\n"
    dnsmasq_config += "log-facility=/var/log/dnsmasq.log\n"

    # Add LBs' addresses for round-robin DNS on *.app.test
    lbs_count.times do |i|
      lb_ip = "192.168.56.#{lbs_starting_ip + i}"
      dnsmasq_config += "address=/*.app.test/#{lb_ip}\n"
    end

    dns.vm.provision "shell", inline: <<-SHELL
      apt-get update
      DEBIAN_FRONTEND=noninteractive apt-get install -y dnsmasq
      cat <<EOF > /etc/dnsmasq.d/k8s.conf
#{dnsmasq_config}
EOF
      # the systemd-resolved was using port 53 therefore the dnsmasq couldn't start
      systemctl stop systemd-resolved
      # the /etc/resolv.conf now has to point to 126.0.0.1
      sed -i 's/nameserver 127.0.0.53/nameserver 127.0.0.1/' /etc/resolv.conf
      systemctl restart dnsmasq
      systemctl enable dnsmasq
      systemctl status dnsmasq --no-pager

      # setup basic firewall rules with ufw allowing only DNS and SSH
      ufw default deny incoming
      ufw default allow outgoing
      ufw allow 22/tcp
      ufw allow 53/tcp
      ufw allow 53/udp
      ufw --force enable
    SHELL
  end
end
